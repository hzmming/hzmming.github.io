---
title: font-size理解
date: 2019-02-20
tags:
  - CSS
categories:
  - CSS
---

任意浏览器的默认字体高都是16px。

所有未经调整的浏览器都符合: 1em=16px。

那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。

**固定尺寸** px

 

```css
p{
    font-size: 16px 
}
div{
    font-size: 16; /* 没写单位的话，默认就是16px */
}
```

**相对尺寸**有 em、%、rem，它们都是相对于某个参考基准的字体大小，来计算当前字体的大小，只是参考基准不同而已。

**1em = 当前元素的font-size值**

又由于font-size值具有继承属性，当前元素继承父元素的font-size，一层层往上，直至根元素，若未修改过，默认根元素的font-size为16px

因此，在使用 em 定义字体大小时，最好在 html 或 body 元素上建立一个基准。假设在 body 中设置的基准大小为 12px：

 

```css
body {
    font-size: 12px;
}
```

如果希望 body 中所有段落的字体大小为 18px，根据上述关系：

18 / 12 = 1. 5

因此，只需将将段落的 font-size 设置为 1.5em 就可以了，这条规则就表示段落文本的字体大小为父元素文本大小的1.5 倍：

 

```css
body p {
    font-size: 1.5em;
}
```

**注意**：很多人简单地认为 “em的参考基准是父元素”，大多数情况下，这样理解是对的。为什么？

其实是因为子元素的font-size默认继承父元素的font-size，因此把 “em基于自身的font-size” 说成 “em基于父元素的font-size”也是可以，但若自身重定义了font-size，这句话就不对了

 

```html
<div style="font-size:12px">
    <p style="font-size: 24px; margin-top:1em;">
        你好
    </p>
</div>
<!-- 
p标签的 margin-top值 为 自身的font-size值（24px）而不是其父元素的font-size值（12px） 
-->
```

**% 的参考基准是父元素**，100% 总是等于父元素 font-size属性的值，即 1em 就等于 100%。也就是说，在用 % 定义字体大小时，只需将 em 的值换算成相应的百分数即可。因此，以下两条声明会得到相同的结果（假设两个段落具有相同的父元素）：

 

```css
p.one {
    font-size: 1.5em;
}
p.one {
    font-size: 150%;
}
```

**需要注意的是，尽管 font-size 是可以继承的，但在使用 % 和 em 定义字体大小时，子元素继承的是计算结果的值，而不是 % 和 em 的数字**。并且，% 和 em 还可以累积。考虑以下代码：

 

```css
p {
    font-size: 12px;
}
em {
    font-size: 200%;
}
strong {
    font-size: 200%;
}
```

 

```html
<p>12px <em> 200% <strong> 200% </strong></em></p>
```

上述代码中，p 为父元素，em 为 p 的子元素，strong 为 em 的子元素。

em 元素的基准是 p 元素，而 strong 元素的基准是 em 元素。计算结果如下：

em：12 × 200% = 24px

strong：24 × 200% = 48px

得到的运行结果如下图所示：

![img](/img/e1a9424f-d6bc-4738-8be1-24dcdc8258cd.png)

在这种多层嵌套的情况下，如果某一个计算结果不是整数，浏览器可能就会取整，子元素再继承取整后的值。如果嵌套很深，下层的字体大小就越来越偏离实际计算值。并且，由于参考基准总是随着元素发生变化，嵌套越深，计算起来也就越困难。

鉴于此，CSS3中新增的一个相对单位 rem（root em的简称），它总是以文档的根元素（即 html 元素）为参考基准，来设置其它元素的字体大小，即 1rem 相当于 html 元素 font-size属性的值。考虑以下代码：

 

```css
html {
    font-size: 10px;
}
p {
    font-size: 1.4rem;
}
```

上述声明中，p 元素的字体大小将是 html 字体大小的1.4倍，则计算得到 p 元素的字体大小就是1.4 × 10px = 14px。

这样一来，无论嵌套多少层，参考基准始终不变，计算字体大小就变得容易多了。不过，需要注意的是，rem 是CSS3新增的一个相对单位，**IE9 以下版本的老浏览器却不支持它**，这也是很多编程人员尚未使用 rem 的原因。

在定义字体大小时，笔者建议在 html 元素中定义绝大多数元素所需要的字体大小，并让所有子元素继承 html 的字体大小。如果某个子元素需要要改变字体大小，则使用相对尺寸 em 或 % 或 rem 重新定义。

这样做的好处是，一方面，绝大多数元素都不必定义字体大小，减少不必要的定义；另一方面，如果完成所有的文字排版后，又要统一调整页面文字大小，就可以只修改 html 中的字体大小，其它所有文字的字体大小会自动变化，修改起来就很容易。

说明：

在某些特殊场景下，需要把 font-size 的值设置为0，来隐藏某些文本。但是，在IE6和IE7中，font-size: 0 的文本却变成了小黑点，并没有完全隐藏。

解决这个问题的最简单办法，就是在 font-size: 0 的同时，把 text-indent 属性设置为一个很大的负值，让这些文本显示在屏幕之外，自然就被隐藏起来。

*原文：https://blog.csdn.net/ixygj197875/article/details/79312549* 